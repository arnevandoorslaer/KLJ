var _a, _b;
import { LitElement } from 'lit-element';
import { Subject, isObservable } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
const unsubscribe = Symbol('unsubscribe');
const subscriptions = Symbol('subscriptions');
class ExistingSubscription {
}
export class RxLitElement extends LitElement {
    constructor() {
        super(...arguments);
        this[_a] = new Subject();
        this[_b] = new Map();
    }
    /**
     * Subscribes to an observable, sets new values to the property of the class and schedules an update.
     * @param propKey Property of the class to receive values.
     * @param stream$ Observable that will be subscribed to.
     */
    subscribe(propKey, stream$) {
        var _c;
        if (!isObservable(stream$))
            throw new Error('Invalid Observable!');
        const existingSubscription = this[subscriptions].get(propKey);
        if (existingSubscription) {
            if ((existingSubscription === null || existingSubscription === void 0 ? void 0 : existingSubscription.stream$) === stream$)
                return;
            else
                (_c = existingSubscription === null || existingSubscription === void 0 ? void 0 : existingSubscription.subscription) === null || _c === void 0 ? void 0 : _c.unsubscribe();
        }
        const subscription = stream$
            .pipe(takeUntil(this[unsubscribe]))
            .subscribe((res) => {
            this[propKey] = res;
            this.requestUpdate();
        });
        this[subscriptions].set(propKey, { stream$, subscription });
    }
    disconnectedCallback() {
        this[unsubscribe].next();
        super.disconnectedCallback();
    }
}
_a = unsubscribe, _b = subscriptions;
//# sourceMappingURL=rx-lit.element.js.map